<?php include "../template/inc/header.php"; ?>
<h1>Объектно-ориентированное программирование</h1>
    <h2>Источники</h2>
<ul>
    <li><a href="https://php-academy.kiev.ua/uk/blog/learning-oop-in-php-asap" target="_blank">Вивчення OOP в PHP якнайшвидше! </a></li>
    <li><a href="http://www.php.su/learnphp/phpoo/" target="_blank">PHP и ООП</a></li>
    <li><a href="https://razrab.info/principy-oop-php/" target="_blank">Принципы ООП PHP (основные понятия и парадигмы)</a></li>
    <li><a href="https://ru.wikipedia.org/wiki/Объектно-ориентированное_программирование" target="_blank">ООП</a></li>
    <li><a href="https://www.php.net/manual/ru/language.oop5.magic.php" target="_blank">Магические методы</a></li>
    <li><a href="https://www.internet-technologies.ru/articles/magicheskie-metody-php.html" target="_blank">Магические методы PHP</a></li>
    <li><a href="https://www.php.net/manual/ru/language.oop5.visibility.php" target="_blank">Область видимости</a></li>
    <li><a href="https://habr.com/ru/post/37576/" target="_blank"> Полиморфизм для начинающих</a></li>
    <li><a href="https://habr.com/ru/post/37610/" target="_blank">Что такое полиморфизм на самом деле. В PHP он тоже существует.</a></li>
    <li><a href="https://habr.com/ru/post/37576/" target="_blank"> Полиморфизм для начинающих </a></li>
    <li>Интерфейс
        <ul>
            <li><a href="https://www.php.net/manual/ru/language.oop5.interfaces.php" target="_blank">Интерфейсы объектов</a></li>
            <li><a href="https://habr.com/ru/post/328890/" target="_blank">Всё, что вы хотели узнать об интерфейсах</a></li>
            <li><a href="https://www.internet-technologies.ru/articles/interfeys-php.html" target="_blank">Интерфейс PHP</a></li>
            <li><a href="https://klisl.com/php_Interface.html" target="_blank">Для чего нужны интерфейсы в PHP</a></li>
            <li><a href="http://www.php.su/articles/?cat=oop&page=002" target="_blank">Абстрактные классы и интерфейсы</a></li>
        </ul>
    </li>
    <li>Абстрактный класс
    <ul>
        <li><a href="https://php.net/manual/ru/language.oop5.abstract.php" target="_blank">Абстрактные классы</a></li>
        <li><a href="http://www.php.su/articles/?cat=oop&page=002" target="_blank">Абстрактные классы и интерфейсы</a></li>
        <li><a href="https://www.internet-technologies.ru/articles/abstraktnyy-klass-php.html" target="_blank">Абстрактный класс PHP</a></li>
        <li><a href="https://true-coder.ru/oop-v-php/oop-v-php-abstraktnye-klassy-i-interfejsy.html" target="_blank">ООП в PHP: Абстрактные классы и интерфейсы</a></li>
        <li><a href="http://lifeexample.ru/php-primeryi-skriptov/abstraktnyiy-klass-php.html" target="_blank">Абстрактный класс php</a></li>
    </ul>

    </li>
    <li>SOLID
<ul>
    <li><a href="https://ru.wikipedia.org/wiki/SOLID_(объектно-ориентированное_программирование)" target="_blank">SOLID</a></li>
    <li><a href="https://habr.com/ru/post/208442/" target="_blank"> Шпаргалка по SOLID-принципам с примерами на PHP </a></li>
</ul>

    </li>
</ul>
<h2>Основы ООП</h2>


    <p>ООП - это парадигма программирования.</p>

    <p>Объектно-ориентированное программирование основано на:</p>
    <ul>
        <li><div class="spoiler_v2">
                <a href="#" class="spoiler-trigger"><span>Инкапсуляции;</span></a>
                <div class="spoiler-block">
                    <p>Инкапсуляция — сокрытие данных и методов. Реализуется с помощью модификаторов доступа.</p>

                    <p>Метод, возвращающий значение поля, называется геттер (от английского get — «получать»).</p>
                    <p>Метод, устанавливающий значение поля, называется сеттер (от английского set — «устанавливать»).</p>
                </div>
            </div></li>
        <li><div class="spoiler_v2">
                <a href="#" class="spoiler-trigger"><span>Полиморфизме;</span></a>
                <div class="spoiler-block">
                    <p>Полиморфизм - это поддержка нескольких реализаций на основе общего интерфейса</p>
                    <p>Полиморфизм — это способность обьекта использовать методы производного класса, который не существует на момент создания базового.</p>
                </div></div>
        </li>
        <li><div class="spoiler_v2">
                <a href="#" class="spoiler-trigger"><span>Наследование.</span></a>
                <div class="spoiler-block">
                    <p>Основная идея наследования заключается в том, что подобные объекты разделяют общие свойства. Поэтому, создавая "общий" класс, мы можем иметь план, чтобы построить наши следующие классы.</p>
                    <p>Представьте себе, если вы будете, свойства автомобиля: цвет, количество колес, мощность, количество сидений и т. Д Имея этот шаблон, мы можем дополнительно специализировать наши автомобили, расширив этот класс: создав гоночный автомобиль, имеющий собственность "нитро" или грузовик, имеет собственность "прицепа". Суть дела: создайте более общий класс, содержащий большинство общих атрибутов, и вы будете иметь гораздо меньше работы, определяя другие объекты только немного другим. Вместо перезаписи всего кода вы просто расширяете его свойства, экономя много времени в процессе.</p>
                </div>
            </div></li>
    </ul>
    <h3>Приватность и публичность в классах</h3>
    <p>Область видимости свойства, метода или константы может быть определена путем использования следующих ключевых слов в объявлении: public, protected или private.</p>
    <ul>
        <li>Доступ к свойствам и методам класса, объявленным как <span class="like_b">public (общедоступный)</span>, разрешен отовсюду.</li>
        <li>Модификатор <span class="like_b">protected (защищенный)</span> разрешает доступ самому классу, наследующим его классам и родительским классам.</li>
        <li>Модификатор <span class="like_b">private (закрытый)</span> ограничивает область видимости так, что только класс, где объявлен сам элемент, имеет к нему доступ.</li>
    </ul>
<hr>
    <h2>Свойства и  методы</h2>
    <p>Класс - это базовое понятие в объектно-ориентированном программировании (ООП). Классы образуют синтаксическую базу ООП. Их можно рассматривать как своего рода "контейнеры" для логически связанных данных и функций (обычно называемых методами — см. ниже). Если сказать проще, то класс - это своеобразный тип данных.</p>
    <p>Экземпляр класса - это объект. Объект - это совокупность данных (свойств) и функций (методов) для их обработки. Свойства и методы называются членами класса. Вообще, объектом является все то, что поддерживает инкапсуляцию.</p>
    <p>Если класс можно рассматривать как тип данных, то объект — как переменную (по аналогии). Скрипт может одновременно работать с несколькими объектами одного класса, как с несколькими переменными.</p>
    <div class="spoiler_v2">
        <a href="#" class="spoiler-trigger"><span>Пример кода</span></a>
        <div class="spoiler-block">
<pre><code>
// Создаем новый класс Coor:
class Coor {
// данные (свойства):
var $name;
var $addr;
// методы:
 function Name() {
 echo "&lt;h3&gt;John&lt;/h3&gt;";
 }
}
// Создаем объект класса Coor:
$object = new Coor;
    </code></pre>
        </div></div>
    <hr>
    <h2>Магические методы</h2>
    <p>Магические методы PHP позволяют разработчикам совершать удивительные трюки в объектно-ориентированном PHP. Магические методы срабатывают в ответ на определенные действия или события.</p>
    <p>Существуют определенные характеристики метода конструктора, которые отличают его от других и делают его уникальным. Во-первых, он вызывается только один раз в момент создания объекта, во-вторых, мы не можем вызвать его явно. Он автоматически вызывается, когда создается экземпляр класса, и используется для инициализации переменных-членов. Мы видим, что этот метод отличается от других, используемых в ООП PHP. По таким характеристикам магические методы и выделяют в отдельную группу.</p>
    <p>В общем, магические методы PHP — это предопределенные методы, выполняемые при каком-либо конкретном событии, они автоматически вызываются, без вызова функции, когда удовлетворяется какое-либо из заданных условий. Например, __construct всегда вызывается при создании экземпляра класса. Магические методы весьма полезны, они предоставляют удивительный функционал для объектно-ориентированного программирования на PHP.</p>
    <hr>
    <h2>Интерфейсы объектов</h2>
    <p><a href="https://www.php.net/manual/ru/language.oop5.interfaces.php" target="_blank" class="like_b">Интерфейсы объектов</a> позволяют создавать код, который указывает, какие методы должен реализовать класс, без необходимости определять, как именно они должны быть реализованы.</p>
    <p>Интерфейсы объявляются так же, как и обычные классы, но с использованием ключевого слова <span class="like_b">interface</span> вместо <span class="like_b">class</span>. Тела методов интерфейсов должны быть пустыми.</p>
    <p>Все методы, определенные в интерфейсах должны быть общедоступными, что следует из самой природы интерфейса.</p>



    <div class="spoiler_v2">
        <a href="#" class="spoiler-trigger"><span>Еще одно объясннеие</span></a>
        <div class="spoiler-block">
    <p>Реальный пример: Вы делаете сайт (CMS), вывод модулей в браузер. Вы не знаете какие модули будут выводиться и кто их будет делать: новости, форум, календарь, блог, ссылки, фотографии... Вы не знаете как модуль будет генерировать HTML, имя класса модуля и как в нем что реализовано. Не знаете и это не ваша проблема и забота. Вам нужно только "заставить" чтобы все модули подчинялись одному методу: ПОКАЖИСЬ ( назовем его show). Для этого создаете абстрактный класс с этим методом. Затем создаете любые модули основываясь на абстрактном классе.</p>

    <p>В итоге вывод модулей выглядит примерно так:</p>
<pre><code>
    foreach($modules as $module) {
    $module->show(); // тут каждый модуль сам генерирует и отображает свой html   код
    }
    </code></pre>
    <p>С помощью базового абстрактного класса вы привели все модули к одной функции вывода show() в HTML.</p>
    <p>Не зная ничего про модуль вы точно знаете что у него есть метод который вам нужен</p>

    <p>Конечно без этого можно обойтись, но с опытом понимаешь что так лучше...</p>
        </div></div>
    <div class="spoiler_v2">
        <a href="#" class="spoiler-trigger"><span>Еще одно объясннеие 2</span></a>
        <div class="spoiler-block">
            <p>Интерфейсы по своей сути аналогичны абстрактным классам, но есть один нюанс: класс может наследовать только один абстрактный класс, а интерфейсов может наследовать несколько. С этого стоит правило, что абстрактный класс стоит писать если Вы хотите в уже рабочем классе полностью наследовать его, или же можно обойтись интерфейсами, которые будут зависит по частям. Одни программисты пользуются в основном абстрактными классами, некоторые интерфейсами, но по настоящему опытные программисты уже на опыте знают где нужно прописать или интерфейс, или абстрактный класс.</p>
        </div></div>
    <div class="spoiler_v2">
        <a href="#" class="spoiler-trigger"><span>Еще одно объясннеие 3</span></a>
        <div class="spoiler-block">
            <p>Интерфейс же — это своего рода контракт: интерфейсы используются в определениях чтобы указать, что объект, который будет использован на самом деле, должен реализовывать (для входных параметров) или будет гарантированно реализовывать (для выходных параметров) набор методов и (что намного важнее!) иметь определённую семантику. Интерфейс вполне может быть и пустым, тем не менее, имплементировать интерфейс означает поддерживать данную семантику.</p>
        </div></div>

    <div class="spoiler_v2">
        <a href="#" class="spoiler-trigger"><span>Пример кода</span></a>
<div class="spoiler-block"><pre><code>
interface iTemplate {
    public function setVariable();
    public function getHtml();
}
class Template implements iTemplate {
    public function setVariable()
        {
    	echo 1;
        }
    public function getHtml()
        {
    	echo 2;
        }
}
$a = new Template();
$a->setVariable();
$a->getHtml();
</code></pre></div></div>


    <ul>
        <li><a href="https://www.php.net/manual/ru/language.oop5.interfaces.php" target="_blank">Интерфейсы объектов</a></li>
        <li><a href="https://habr.com/ru/post/328890/" target="_blank">Всё, что вы хотели узнать об интерфейсах</a></li>
        <li><a href="https://www.internet-technologies.ru/articles/interfeys-php.html" target="_blank">Интерфейс PHP</a></li>
        <li><a href="https://klisl.com/php_Interface.html" target="_blank">Для чего нужны интерфейсы в PHP</a></li>
        <li><a href="http://www.php.su/articles/?cat=oop&page=002" target="_blank">Абстрактные классы и интерфейсы</a></li>
    </ul>
<hr>
<h2>Абстрактный класс</h2>
    <p><a href="https://php.net/manual/ru/language.oop5.abstract.php" target="_blank" class="like_b">Абстрактные классы</a> могут содержать описание абстрактных методов. Для таких методов указывается лишь заголовок с ключевым словом abstract и всеми прочими атрибутами, указываемыми при объявлении метода. Абстрактные методы не имеют тела или реализации, они лишь описывают, что должен уметь делать объект, а как он это будет делать – проблема наследников абстрактного класса.</p>
    <p>Экземпляр абстрактного класса создавать нельзя, так как в противном случае могла произойти попытка вызвать от этого экземпляра абстрактный метод, что абсурдно, так как он не имеет реализации.</p>


    <div class="spoiler_v2">
        <a href="#" class="spoiler-trigger"><span>Еще одно объясннеие</span></a>
        <div class="spoiler-block">
    <p>Абстрактные классы - это классы, содержащие один или несколько абстрактных методов. Абстрактный метод - это метод, объявленный, но не содержащий реализации. Абстрактные классы не могут быть созданы и требуют, чтобы подклассы предоставляли реализации абстрактных методов.</p>
        </div>
    </div>
    <div class="spoiler_v2">
        <a href="#" class="spoiler-trigger"><span>Еще одно объясннеие 2</span></a>
        <div class="spoiler-block">
            <p>Абстрактный класс предназначен для написание набросок приложения. То есть разработчик пишет программу, или некоторый функционал и если разработчик опытный, он для начала будет писать проектировку работы программы, а именно проектировку методов, который будет наследовать будущий класс. Абстрактный класс не несет в себе никакую функциональность, это только наброски. Особенно данные классы разрешают другим программистам разобраться в работе написанной программы.</p>
        </div>
    </div>
    <div class="spoiler_v2">
        <a href="#" class="spoiler-trigger"><span>Еще одно объясннеие 3</span></a>
        <div class="spoiler-block">
            <p>Представьте, что вам нужно описать модель работы бензозаправки. Для ее отработки вам безусловно понадобится экземпляр автомобиля. Но в данный момент вы не хотите задумываться о конкретной реализации этого класса - его методы могут возвращать mock значения. К тому же вам наверняка могут понадобится свойства в этом классе и соответственно рабочие геттеры и сеттеры. К тому же, стоит проконтроллировать, что соседние разработчики не будут дописывать к этому классу какую-то конкретную логику, чтобы потом использовать ее в своем коде и таким образом связать ваш код лишними зависимостями. Для этих целей идеально подойдет именно абстрактный класс, созданием которого вы говорите: "это класс с очень общей логикой и возможностью хранить данные в свойствах. В последствии мы сделаем для него конкретных потомков, но сейчас не до этого. Пожалуйста, не дописывайте сюда методов с конкретной логикой."</p>
        </div>
    </div>
    <div class="spoiler_v2">
        <a href="#" class="spoiler-trigger"><span>Еще одно объясннеие 4</span></a>
        <div class="spoiler-block">
            <p>Абстрактный класс — это «заготовка» класса: реализовано большинство методов (включая внутренние), кроме нескольких. Эти несколько нереализованных методов вполне могут быть внутренними методами класса, они лишь уточняют детали имплементации. Абстрактный класс — средство для повторного использования кода, средство, чтобы указать, какой метод обязан быть перекрыт для завершения написания класса.</p>
        </div>
    </div>



    <ul>
        <li><a href="https://php.net/manual/ru/language.oop5.abstract.php" target="_blank">Абстрактные классы</a></li>
        <li><a href="http://www.php.su/articles/?cat=oop&page=002" target="_blank">Абстрактные классы и интерфейсы</a></li>
        <li><a href="https://www.internet-technologies.ru/articles/abstraktnyy-klass-php.html" target="_blank">Абстрактный класс PHP</a></li>
        <li><a href="https://true-coder.ru/oop-v-php/oop-v-php-abstraktnye-klassy-i-interfejsy.html" target="_blank">ООП в PHP: Абстрактные классы и интерфейсы</a></li>
    </ul>
<hr>
<h2>SOLID</h2>
    <p>SOLID (сокр. от англ. single responsibility, open-closed, Liskov substitution, interface segregation и dependency inversion) в программировании — мнемонический акроним, введённый Майклом Фэзерсом (Michael Feathers) для первых пяти принципов, названных Робертом Мартином в начале 2000-х, которые означали пять основных принципов объектно-ориентированного программирования и проектирования.</p>
    <p>При создании программных систем использование принципов SOLID способствует созданию такой системы, которую будет легко поддерживать и расширять в течение долгого времени. Принципы SOLID — это руководства, которые также могут применяться во время работы над существующим программным обеспечением для его улучшения - например для удаления «дурно пахнущего кода».</p>
    <p>Стратегии гибкой и адаптивной разработки предполагают написание кода с соблюдением принципов SOLID.</p>
    <p>Признаки плохого проекта</p>
    <ul>
        <li>Закрепощённость: система с трудом поддается изменениям, поскольку любое минимальное изменение вызывает эффект "снежного кома", затрагивающего другие компоненты системы.</li>
        <li>Неустойчивость: в результате осуществляемых изменений система разрушается в тех местах, которые не имеют прямого отношения к непосредственно изменяемому компоненту.</li>
        <li>Неподвижность: достаточно трудно разделить систему на компоненты, которые могли бы повторно использоваться в других системах.</li>
        <li>Вязкость: сделать что-то правильно намного сложнее, чем выполнить какие-либо некорректные действия.</li>
        <li>Неоправданная сложность: проект включает инфраструктуру, применение которой не влечёт непосредственной выгоды.</li>
        <li>Неопределенность: исходный код трудно читать и понимать. Недостаточно четко выражено содержимое проекта.</li>
    </ul>
    <p>Избавиться от "признаков плохого проекта" помогают следующие пять принципов SOLID:</p>
    <table class="tbl_2">
        <tr>
            <td>Инициал</td>
            <td>Представляет</td>
            <td>Название, понятие</td>
        </tr>
        <tr>
            <td>S</td>
            <td>SRP</td>
            <td>Принцип единственной ответственности (The Single Responsibility Principle)<br>
                Каждый класс выполняет лишь одну задачу.</td>
        </tr>
        <tr>
            <td>O </td>
            <td>OCP</td>
            <td>Принцип открытости/закрытости (The Open Closed Principle)<br>
                «программные сущности … должны быть открыты для расширения, но закрыты для модификации.»</td>
        </tr>
        <tr>
            <td>L </td>
            <td>LSP</td>
            <td>Принцип подстановки Барбары Лисков (The Liskov Substitution Principle)<br>
                Объекты в программе могут быть заменены их наследниками без изменения свойств программы
            </td>
        </tr>
        <tr>
            <td>I </td>
            <td>ISP</td>
            <td>
                Принцип разделения интерфейса (The Interface Segregation Principle)<br>
                «много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.»
            </td>
        </tr>
        <tr>
            <td>D</td>
            <td>DIP</td>
            <td>Принцип инверсии зависимостей (The Dependency Inversion Principle)<br>
                «Зависимость на Абстракциях. Нет зависимости на что-то конкретное.»<br>
                <ul>
                    <li>Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.</li>
                    <li>Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.</li>
                </ul>
            </td>
        </tr>
    </table>

    <hr>
    <p>Композиция и агрегация</p>
<!--
https://www.codewars.com/?language=php

// патерны
// https://refactoring.guru/ru/design-patterns/php
-->
    <hr>
<h2>Паттерны</h2>

    <p>Паттерн (от англ. Pattern) — образец, шаблон. Описывает типичные способы решения часто встречающихся проблем.</p>
    <p>Представьте, что вы хотите сделать новый автомобиль, но вы никогда этим не занимались. Сколько колес и почему вы спроектируете для него? Сейчас вы уже скорее всего скажете что 4, однако почему не 3, 5, 10, 20? Потому-что практикой использования уже было выяснено, что обычные автомобили лучше всего делать на 4-х колесах — это шаблон проектирования сформированный временем. Именно такому же подходу и служат паттерны в ООП и вы не столкнетесь с ними в разработке до тех пор, пока вам не потребуется «сделать автомобиль». Однако иногда случается так, что вы создаете «трицикл», и только потом, набив несколько шишек с его устойчивость и неудачным вписыванием в колею на дороге, узнаете что существует паттерн «автомобиль», который значительно упростил бы вам жизнь, знай вы про него ранее.</p>
    <p><span class="like_b">Singleton (Синглтон, одиночка)</span> относиться к классу порождающих паттернов. Он используется для создания всего одного экземпляра класса, и гарантирует, что во время работы программы не появиться второй. Например в схеме MVC, зачастую этот паттерн используется для порождения главного контроллера (фронтового)</p>

    <p><span class="like_b">Декоратор</span> — это структурный паттерн, который позволяет добавлять объектам новые поведения на лету, помещая их в объекты-обёртки.</p>

    <p>Декоратор позволяет оборачивать объекты бесчисленное количество раз благодаря тому, что и обёртки, и реальные оборачиваемые объекты имеют общий интерфейс.</p>
    <p><span class="like_b">Фасад</span> — это структурный паттерн проектирования, который предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.</p>
    <p><span class="like_b">Абстрактная фабрика</span> — это порождающий паттерн проектирования, который позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов.</p>
    <p><span class="like_b">Фабричный метод</span> — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.</p>
    <p><span class="like_b">Стратегия</span> — это поведенческий паттерн проектирования, который определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы.</p>





    <p>Больше об патернах тут, с примерами</p>
<ul>
<li><a href="https://refactoring.guru/ru/design-patterns/php" target="_blank">Каталог PHP-примеров</a></li>
<li><a href="https://designpatternsphp.readthedocs.io/ru/latest/README.html" target="_blank">DesignPatternsPHP</a></li>
<li><a href="https://habr.com/ru/post/214285/" target="_blank"> Шаблоны проектирования PHP. Часть 1. Порождающие </a></li>
<li><a href="https://habr.com/ru/company/mailru/blog/325492/" target="_blank"> Шаблоны проектирования с человеческим лицом </a></li>
<li><a href="https://habr.com/ru/post/136766/" target="_blank"> Паттерны ООП в метафорах </a></li>
<li><a href="https://habr.com/ru/post/150267/" target="_blank"> Реализация MVC паттерна на примере создания сайта-визитки на PHP </a></li>
</ul>



    <hr>
    <h2>MVC</h2>

    <p>Шаблон MVC описывает простой способ построения структуры приложения, целью которого является отделение бизнес-логики от пользовательского интерфейса. В результате, приложение легче масштабируется, тестируется, сопровождается и конечно же реализуется.</p>
    <p>Рассмотрим концептуальную схему шаблона MVC (на мой взгляд — это наиболее удачная схема из тех, что я видел):</p>
    <img alt="mvc-schema" src="/images/mvc_img.png">
    <p>В архитектуре MVC модель предоставляет данные и правила бизнес-логики, представление отвечает за пользовательский интерфейс, а контроллер обеспечивает взаимодействие между моделью и представлением.</p>
    <p>Типичную последовательность работы MVC-приложения можно описать следующим образом:</p>
    <ol>
        <li>При заходе пользователя на веб-ресурс, скрипт инициализации создает экземпляр приложения и запускает его на выполнение.
            При этом отображается вид, скажем главной страницы сайта.
        </li>
        <li>Приложение получает запрос от пользователя и определяет запрошенные контроллер и действие. В случае главной страницы, выполняется действие по умолчанию (<i>index</i>).
        </li>
        <li>Приложение создает экземпляр контроллера и запускает метод действия,
            в котором, к примеру, содержаться вызовы модели, считывающие информацию из базы данных.
        </li>
        <li>После этого, действие формирует представление с данными, полученными из модели и выводит результат пользователю.
        </li>
    </ol>
    <p><span class="like_b">Модель</span> — содержит бизнес-логику приложения и включает методы выборки (это могут быть методы ORM), обработки (например, правила валидации) и предоставления конкретных данных, что зачастую делает ее очень толстой, что вполне нормально.</p>
    <p>Модель не должна напрямую взаимодействовать с пользователем. Все переменные, относящиеся к запросу пользователя должны обрабатываться в контроллере.</p>
    <p>Модель не должна генерировать HTML или другой код отображения, который может изменяться в зависимости от нужд пользователя. Такой код должен обрабатываться в видах.</p>
    <p>Одна и та же модель, например: модель аутентификации пользователей может использоваться как в пользовательской, так и в административной части приложения. В таком случае можно вынести общий код в отдельный класс и наследоваться от него, определяя в наследниках специфичные для подприложений методы.</p>
    <p><span class="like_b">Вид</span> — используется для задания внешнего отображения данных, полученных из контроллера и модели.</p>
    <p>Виды cодержат HTML-разметку и небольшие вставки PHP-кода для обхода, форматирования и отображения данных.</p>
    <p>Не должны напрямую обращаться к базе данных. Этим должны заниматься модели.</p>
    <p>Не должны работать с данными, полученными из запроса пользователя. Эту задачу должен выполнять контроллер.</p>
    <p>Может напрямую обращаться к свойствам и методам контроллера или моделей, для получения готовых к выводу данных.</p>
    <p>Виды обычно разделяют на общий шаблон, содержащий разметку, общую для всех страниц (например, шапку и подвал) и части шаблона, которые используют для отображения данных выводимых из модели или отображения форм ввода данных.</p>
    <p><span class="like_b">Контроллер</span> — связующее звено, соединяющее модели, виды и другие компоненты в рабочее приложение. Контроллер отвечает за обработку запросов пользователя. Контроллер не должен содержать SQL-запросов. Их лучше держать в моделях. Контроллер не должен содержать HTML и другой разметки. Её стоит выносить в виды.</p>
    <p>В хорошо спроектированном MVC-приложении контроллеры обычно очень тонкие и содержат только несколько десятков строк кода. Чего, не скажешь о Stupid Fat Controllers (SFC) в CMS Joomla. Логика контроллера довольно типична и большая ее часть выносится в базовые классы.</p>
    <p>Модели, наоборот, очень толстые и содержат большую часть кода, связанную с обработкой данных, т.к. структура данных и бизнес-логика, содержащаяся в них, обычно довольно специфична для конкретного приложения.</p>


    <hr>
    <h2>Практика</h2>
<ul>
    <li><a href="/oop/working_php_oop_1.php">Практика на занятии</a></li>
    <li><a href="/oop/working_php_oop_2.php">Домашняя практика</a></li>
</ul>






<?php



 include "../template/inc/footer.php"; ?>